---
timezone: Asia/Shanghai
---

# zhouCode

1. zhouCode，参加完一周前的协议学习，收获很多，这次继续狠狠地学习！
2. 你认为你会完成本次残酷学习吗？会
3. 你的联系方式（[zhouG1n](https://t.me/zhouG1n)）

# Notes

<!-- Content_START -->

## 2025.03.10

已知区块链有众多节点，每个节点都要保存完整的区块（理论上），但是每时每刻都在发生交易，这就导致每个节点实际上并不能真正的同时保存完全一致的内容，总会有一些节点先保存一部分数据。也就是**传播延迟**（propagation delay）

在POW时期，有可能出现2个矿工同时发现合法区块的情况，就会导致**暂时分叉**（temporal fork）一个称为主链，另一个称为叔父区块（uncles），叔父区块也会获得部分奖励。

POS机制中，新区块由投票决定，且区块的提议者由随机或者预先设定的调度机制选出，所以大大降低了多区块同时产生的可能性。由于只有一个指定的区块提议者负责出块，再加上更高效的共识和出块协调机制，网络中几乎不会出现由于传播延迟而导致的竞争性出块现象，因此也就没有了叔块的概念。

但是区块链的不确定性除了上述问题外还体现在并发交易的处理的不确定性。

**DApp**

**去中心化应用（DApp）** 一般由两部分组成：

- **用户看到的前端界面**（比如网页）；
- **后台运行的智能合约**（区块链上的程序）。

大多数 DApp（约 75%）的前端是用 JavaScript 写的网页，需要频繁和区块链网络交互。不过，由于前端本身不在链上，它需要通过 **以太坊节点** 提供的 **RPC 接口** 来和区块链沟通。

**举个实际例子**：
假设一个众筹 DApp 的前端想要显示用户的捐款记录，它会调用 `eth_getLogs` 方法获取数据；当用户发起新捐款时，前端则通过 `eth_sendTransaction` 方法提交交易，更新链上状态。

**但直接操作节点有两个大问题**：

1. **参数容易出错**：
   RPC 方法的参数格式很麻烦，比如要求「20 字节的十六进制地址」或「32 字节的十六进制字符串数组」，普通人很容易输错。
2. **没有实时通知功能**：
   区块链的交易确认时间不确定（比如可能几秒或几分钟），但节点不会主动通知前端「交易是否完成」。用户只能反复调用方法（比如不停查余额）才能知道结果，非常低效。

**所以实际开发中**，DApp 会用现成的 **JavaScript 工具库**（比如 ethers.js、web3.js）。这些工具做了两件事：

- 自动把参数转换成正确的格式（比如地址补全 0x 前缀）；
- 提供「回调通知」功能（比如交易成功后自动触发更新界面）。

前端（用户界面）在发起交易时，首先通过两个方法（`getAccounts`和`getTransactionCount`）获取两类信息：

1. **用户拥有的钱包地址**；
2. **该地址已完成的交易次数**（称为 `nonce`，类似交易流水号）。

接着，它会调用 `send` 方法向后台的 ERC20 智能合约发送一笔“铸造代币”的交易请求。如果交易成功，系统会返回一个交易凭证。

这里的关键点在于：**每次成功交易后，`nonce` 必须自动加 1**。如果 `nonce` 值错误（比如重复或跳过），可能导致交易被直接拒绝，或者长时间卡在等待状态。

但问题在于：用户可能无意中连接到不同的区块链节点服务（RPC 服务）。如果某个节点返回的 `nonce` 值不准确（比如比其他节点少 1），就会引发上述问题。这种情况下，即使代码逻辑正确，也会因为节点数据不同步而导致交易异常。

## 2025.03.11

**学习JSON-RPC**

每种[以太坊客户端](https://ethereum.org/zh/developers/docs/nodes-and-clients/#execution-clients)均实现了 [JSON-RPC 规范(opens in a new tab)](https://github.com/ethereum/execution-apis)，因而应用程序可以依赖一组统一的方法，而与具体节点或客户端实现无关。

[JSON-RPC(opens in a new tab)](https://www.jsonrpc.org/specification) 是一种无状态的、轻量级远程过程调用 (RPC) 协议。它定义了一些数据结构及其处理规则。它与传输无关，因为这些概念可以在同一进程，通过接口、超文本传输协议或许多不同的消息传递环境中使用。它使用 JSON (RFC 4627) 作为数据格式。
## 2025.03.12

### **Conventions**

JSON-RPC 使用 JSON，因此具有相同的类型系统（参见 http://www.json.org 或 RFC 4627）。JSON 可以表示四种基本类型（字符串、数字、布尔值和空值）以及两种结构化类型（对象和数组）。本规范中的“基本”一词指代这四种基本 JSON 类型中的任何一种。“结构化”一词指代这两种结构化 JSON 类型中的任何一种。当本文件提到任何 JSON 类型时，其首字母总是大写的：对象、数组、字符串、数字、布尔值、空值。真和假也大写。

所有客户端和服务器之间交换的成员名称，在考虑任何匹配时，应被视为大小写敏感。函数、方法和过程这些术语可以认为是可互换的。

客户端定义为请求对象的来源和响应对象的处理者。

服务器定义为响应对象的来源和请求对象的处理器。

本规范的某个实现可以轻松地同时扮演这两个角色，即使是对不同的客户端或相同的客户端。本规范不涉及这一层复杂性。

### **Request object**

一个 RPC 调用通过向服务器发送请求对象来表示。请求对象具有以下成员：

-  JSON-RPC

  一个指定 JSON-RPC 协议版本的字符串。必须是“2.0”。

-  方法

  包含要调用的方法名称的字符串。以单词 rpc 开头后跟一个点字符（U+002E 或 ASCII 46）的方法名称保留用于 rpc-内部方法和扩展，不得用于其他任何用途。

-  参数

  结构化值，用于在调用方法期间持有要使用的参数值。此成员可以省略。

- id

  客户端建立的标识符，必须包含一个字符串、数字或（如果包含）NULL 值。如果不包含，则假定是一个通知。该值通常不应为 NULL，数字不应包含小数部分。

服务器必须以响应对象中包含的相同值进行回复。此成员用于关联两个对象之间的上下文。

不建议在请求对象中将 Null 用作 id 成员的值，因为本规范使用 Null 值表示具有未知 id 的响应。此外，由于 JSON-RPC 1.0 使用 Null 值作为通知的 id，这可能会在处理时造成混淆。

分数部分可能存在问题，因为许多十进制分数不能精确地表示为二进制分数。

#### 通知

通知是一个没有“id”成员的请求对象。表示通知的请求对象意味着客户端对相应的响应对象不感兴趣，因此不需要向客户端返回响应对象。服务器不得回复通知，包括那些在批量请求中的通知。

通知按定义是不可确认的，因为它们没有返回的响应对象。因此，客户端将不会意识到任何错误（例如“无效参数”、“内部错误”）。

#### 参数结构

如果存在，RPC 调用的参数必须以结构化值的形式提供。可以通过数组按位置或通过对象按名称提供。

- by-position: params 必须是一个数组，包含服务器期望的值顺序。
- by-name: params 必须是一个对象，其成员名称必须与服务器期望的参数名称匹配。缺少期望的名称可能会导致生成错误。名称必须完全匹配，包括大小写，以符合方法期望的参数。

### Response Object

当进行 RPC 调用时，服务器必须回复一个响应，除非是通知。响应以单个 JSON 对象的形式表达，具有以下成员：

-  JSON-RPC

  一个指定 JSON-RPC 协议版本的字符串。必须是“2.0”。

-  结果

  此成员在成功时是必需的。 此成员必须在调用方法时发生错误的情况下不存在。 该成员的值由在服务器上调用的方法确定。

-  错误

  此成员在错误时是必需的。 此成员必须在调用过程中未触发错误的情况下不存在。 该成员的值必须是第 5.1 节中定义的对象。

- id

   此成员是必需的。 它必须与请求对象中 id 成员的值相同。 如果请求对象中检测到 ID 错误（例如解析错误/无效请求），它必须是空。

结果成员或错误成员必须包含其一，但不能同时包含两者。

### Error Object

当 RPC 调用遇到错误时，响应对象必须包含一个名为 error 的成员，其值是一个具有以下成员的对象：

-  代码

  一个表示发生错误类型的数字。 这是一个整数。

-  消息

  一个字符串，提供错误简短描述。 消息应限制为简洁的单句。

-  数据

  原始值或结构化值，包含有关错误的附加信息。  此内容可省略。 该成员的值由服务器定义（例如，详细错误信息、嵌套错误等）。

错误代码从-32768 到-32000 是保留用于预定义错误的。在此范围内但未在以下内容中明确定义的任何代码，保留供将来使用。错误代码几乎与以下网址建议的 XML-RPC 相同：[http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php](http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php)

| 代码             | 消息       | 含义                                                     |
| :--------------- | :--------- | :------------------------------------------------------- |
| -32700           | 解析错误   | 服务器收到无效的 JSON。 服务器解析 JSON 文本时发生错误。 |
| -32600           | 无效请求   | 发送的 JSON 不是一个有效的请求对象。                     |
| -32601           | 方法未找到 | 方法不存在/不可用。                                      |
| -32602           | 无效的参数 | 无效的方法参数。                                         |
| -32603           | 内部错误   | 内部 JSON-RPC 错误。                                     |
| -32000 至 -32099 | 服务器错误 | 保留供实现定义的服务器错误使用。                         |

剩余空间可用于应用定义的错误。

## 2025.03.13

以太坊中使用RPC主要通过Web3.js或者ethers.js等库，其内置了JSON-RPC的调用

例如，通过调用 `web3.eth.getBalance(address)` 就可以查询某个地址的余额，而不需要手动构造 JSON 请求。

### RPC 使用流程

下面以一个典型 DApp 前端调用 RPC 的流程为例：

1. **选择 RPC 服务提供商**

   - 可以使用自己运行的以太坊节点（例如 geth 或 openethereum），也可以使用第三方提供的服务（如 Infura、Alchemy 等）。这些服务提供一个可访问的节点 URL。
   - DApp 配置中会指定这个 RPC 端点，通常是一个 HTTPS 或 WebSocket 地址。

2. **建立连接**

   - 前端（或后端）通过 RPC 库（如 Web3.js 或 ethers.js）与指定的节点建立连接。

   - 例如，在 Web3.js 中：

     ```
     js复制编辑const Web3 = require('web3');
     const web3 = new Web3('https://mainnet.infura.io/v3/YOUR-PROJECT-ID');
     ```

3. **查询数据**

   - 通过调用 RPC 方法查询区块链数据：
     - 查询余额：`web3.eth.getBalance(address)`
     - 查询交易信息：`web3.eth.getTransaction(txHash)`
     - 获取当前区块号：`web3.eth.getBlockNumber()`
   - 这些调用底层都会构造一个 JSON-RPC 请求并发送给节点，然后节点返回相应的数据。

4. **发送交易**

   - 当用户需要执行某个状态变更（例如转账或调用智能合约）时：
     - 前端构造一笔交易，包括：发送地址、接收地址、gas 限额、gas 价格、数据（如果调用合约方法）等。
     - 用户使用钱包（如 MetaMask）或本地私钥对交易进行签名。
     - 签名后的交易通过 RPC 方法（例如 `eth_sendRawTransaction`）发送到节点。
     - 节点验证交易签名和其他参数，将交易广播到整个网络。

5. **监听事件与结果确认**

   - DApp 还可以通过 RPC 订阅机制（例如使用 WebSocket 订阅 `logs` 或 `newHeads`）来监听智能合约事件或新区块的生成，从而对用户的操作给予反馈。

   - 例如，使用 ethers.js 监听合约事件：

     ```javascript
     contract.on("Transfer", (from, to, value, event) => {
         console.log(`Transfer from ${from} to ${to} of ${value}`);
     });
     ```

### 小结

- **抽象化库的作用**：像 Web3.js 和 ethers.js 将 JSON-RPC 的繁琐细节封装起来，开发者只需要调用库函数即可实现查询、提交交易、监听事件等操作。
- **钱包的整合**：大部分 DApp 都集成了钱包（例如 MetaMask），它会负责管理用户的私钥、签名交易以及连接到 RPC 端点，简化了前端开发。
- **安全性与性能**：使用稳定的第三方 RPC 服务可以提高访问速度和稳定性，但也需要注意服务的安全性和去中心化程度，确保数据来源可靠。
<!-- Content_END -->
